// Алгоритм Дейкстры - алгоритм, который нужен для поиска кратчайшего пути в графе.
// Если в поиске в ширину, мы находим кратчайший путь, передвигаясь по вершинам графа и неважно, длительный этот путь или нет.
// Самое главное - это количество пройденных участков.
// То в алгоритме Дейкстры учитывается и длина пройденного ребра, так называемый "вес".
// Именно в этом случае нужно воспользоваться алгоритмом Дейкстры, чтобы высчитать минимально-короткий путь и добраться до пункта назначения за кратчайший промежуток времени.
// За начальную точку принимаем A, а конечную как G.
// Составляется табличка, в которую на первом этапе записываются значения тех вершин, в которые мы можем попасть.
// Все остальные вершины являются недостижимыми и мы их помечяем знаком бесконечности.
// На втором этапе мы помечяем эти вершины, как рассмотренные.
// На третьем этапе мы рассматриваем вершины, в которые можем попасть из точек, полученных во втором этапе.
// Опять же помечаем эти точки как уже рассмотренные.
// На четвёртом этапе мы достигаем точки G, но у нас происходит перерасчёт, т.е. мы находим путь до конечной точки за наиболее кратчайший промежуток времени.
// Значит перезаписываем значение в таблице.
// И на след. этапе мы проделываем всё то же самое и находим самый оптимальный путь.

// Поиск кратчайшего пути в графе.

const graph = {};
graph.a = {b: 2, c: 1};
graph.b = {f: 7};
graph.c = {d: 5, e: 2};
graph.d = {f: 2};
graph.e = {f: 1};
graph.f = {g: 1};
graph.g = {};


function shortPath(graph, start, end) {
    const costs = {};                                   // Объект, который будет хранить минимальные стоимости всех ребёр
    const processed = [];                               // Массив, который будет хранить обработанные объекты
    let neighbors = {};                                 // Объект, в который будем добавлять ближайших соседей
    Object.keys(graph).forEach(node => {                // В цикл добавили значения для тех вершин, в которые мы можем попасть со стартовой
        if(node !== start) {
            let value = graph[start][node];
            costs[node] = value || 10000000;
        }
    });
    let node = findNodeLowerCost(costs, processed);
    while (node) {
        const cost = costs[node];                       // Узел с минимальной стоимостью
        neighbors = graph[node];                        // И в цикле последовательно перебираю узлы с минимальными стоимостями обновляли значения в таблице, которой мы хранили минимальные пути.
        Object.keys(neighbors).forEach(neighbor => {
            let newCost = cost + neighbors[neighbor];
            if (newCost < costs[neighbor]) {
                costs[neighbor] = newCost;
            }
        })
        processed.push(node);
        node = findNodeLowerCost(costs, processed);     // Пометка каждого обработанного узла
    }
    return costs;                                       // И искали новый узел
}

function findNodeLowerCost(costs, processed) {
    let lowestCost = 10000000;
    let lowestNode;
    Object.keys(costs).forEach(node => {
        let cost = costs[node];
        if (cost < lowestCost && !processed.includes(node)) {
            lowestCost = cost;
            lowestNode = node;
        }
    })
    return lowestNode;
}

console.log(shortPath(graph, 'a', 'g'));